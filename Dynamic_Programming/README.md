# Dynamic Programming
> 동적 계획법, 메모리 공간을 약간 더 사용하여 연산 속도를 증가시킬 수 있는 방법

- ex) 피보나치 수열 : 이전 두 항의 합을 현재의 항으로 설정하는 수열
- n번째 피보나치 수 = (n-1)번째 피보나치 수 + (n-2)번째 피보나치 수
- 단, 1번째 피보나치 수 =1, 2번째 피보나치수 =1
  
- 위와 같은 점화식을 재귀 함수를 사용하여 구현할 수 있다.
```python
def fibo():
    if x == 1 or x ==2:
      return 1
    return fibo(x-1) + fibo(x-2)
print(fibo(4))
```
그러나 위와 같은 재귀함수 형식으로 작성할 시 f(n)함수에서 n이 커지면 커질수록 수행시간이 기하급수적으로 늘어난다는 문제가 발생한다. <br>
시간 복잡도 : O(2$^n$)

> 아래와 같은 조건을 만족한다면 다이나믹 프로그래밍을 사용하여 효율적으로 해결이 가능한 문제.
  - 큰 문제를 작은 문제로 나눌 수 있다.
  - 작은 문제에서 구한 정답은 그것을 포함하는 큰 문제에서도 동일하다.
#### 피보나치 수열은 이러한 조건을 만족하고 있다.
## 다이나믹 프로그래밍 구현
### 메모이제이션 기법(Memoization), 탑 다운
> 한 번 구한 결과를 메모리 공간에 메모.<br>
> 같은 식을 다시 호출하면 메모한 결과를 그대로 가져오는 기법.<br>
> 캐싱(Caching)을 사용하여 값을 저장한다.

```python
#한 번 계산된 결과를 Memoization하기 위한 리스트 초기화
d = [0] * 100

def fibo(): # 탑 다운 다이나믹 프로그래밍
    if x == 1 or x ==2:
      return 1
    if d[x] != 0:
      return d[x]
    d[x] = fibo(x-1) + fibo(x-2)
    return d[x]

print(fibo(99))
```
- 시간 복잡도 : O(N)
- f(1)을 구한 다음 그 값이 f(2)를 푸는데 사용되고, f(2)의 값이 f(3)을 푸는데 사용되는 방식으로 이어지기 때문이다.
```python
d = [0] * 100

def fibo(): # 탑 다운 다이나믹 프로그래밍
    print('f(' + str(x) + ')', end = ' ')  
    if x == 1 or x ==2:
      return 1
    if d[x] != 0:
      return d[x]
    d[x] = fibo(x-1) + fibo(x-2)
    return d[x]

fibo(6)
```
- 위와 같이 재귀 함수를 이용하여 다이나믹 프로그래밍 소스코드를 작성하는 방법을 큰 문제를 해결하기 위해 작은 문제를 호출한다고 하여 탑다운 방식(Top-Down)이라고 한다. : 하향식

### DP 테이블, 바텀 업
```python
#한 번 계산된 결과를 저장하기 위한 DP테이블 초기화
d = [0] * 100

#첫 번째, 두 번째 피보나치 수 = 1
d[1] = 1
d[2] = 1
n = 99

# 바텀업 다이나믹 프로그래밍
for i in range(3, n+1):
  d[i] = d[i-1] + d[i-2]

print[d(n)]
```
- 위와 같이 단순히 반복문을 사용하여 소스코드를 작성할 경우 보텀업 방식(Bottom-Up)이라고 한다. : 상향식

